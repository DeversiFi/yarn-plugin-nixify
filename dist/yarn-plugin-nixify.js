module.exports={name:"yarn-plugin-nixify",factory:function(e){var n;return(()=>{"use strict";var t={d:(e,n)=>{for(var a in n)t.o(n,a)&&!t.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:n[a]})},o:(e,n)=>Object.prototype.hasOwnProperty.call(e,n),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},a={};t.r(a),t.d(a,{default:()=>b});const i=e("@yarnpkg/core"),o=e("clipanion");class r extends o.Command{constructor(...e){super(...e),this.locator=o.Option.String()}async execute(){const e=await i.Configuration.find(this.context.cwd,this.context.plugins),{project:n}=await i.Project.find(e,this.context.cwd),t=await i.Cache.find(e),a=e.makeFetcher();return(await i.StreamReport.start({configuration:e,stdout:this.context.stdout},(async e=>{const{locatorHash:o}=i.structUtils.parseLocator(this.locator,!0),r=n.originalPackages.get(o);r?await a.fetch(r,{checksums:n.storedChecksums,project:n,cache:t,fetcher:a,report:e}):e.reportError(0,"Invalid locator")}))).exitCode()}}r.paths=[["nixify","fetch-one"]];const s=e("@yarnpkg/fslib"),c=e("crypto");class l extends o.Command{constructor(...e){super(...e),this.locator=o.Option.String(),this.source=o.Option.String(),this.installLocation=o.Option.String()}async execute(){const e=await i.Configuration.find(this.context.cwd,this.context.plugins),{project:n}=await i.Project.find(e,this.context.cwd);return await n.restoreInstallState({restoreResolutions:!1}),(await i.StreamReport.start({configuration:e,stdout:this.context.stdout},(async t=>{await n.resolveEverything({report:t,lockfileOnly:!0});const a=i.structUtils.parseLocator(this.locator,!0),o=n.storedPackages.get(a.locatorHash);if(!o)return void t.reportError(0,"Invalid locator");const r=s.ppath.join(n.cwd,this.installLocation);await s.xfs.mkdirpPromise(s.ppath.dirname(r)),await i.execUtils.execvp("cp",["-R",this.source,r],{cwd:n.cwd,strict:!0}),await i.execUtils.execvp("chmod",["-R","u+w",r],{cwd:n.cwd,strict:!0});const l=(0,c.createHash)("sha512");l.update(process.versions.node),e.triggerHook((e=>e.globalHashGeneration),n,(e=>{l.update("\0"),l.update(e)}));const p=l.digest("hex"),d=new Map,h=e=>{let t=d.get(e.locatorHash);if(void 0!==t)return t;const a=n.storedPackages.get(e.locatorHash);if(void 0===a)throw new Error("Assertion failed: The package should have been registered");const o=(0,c.createHash)("sha512");o.update(e.locatorHash),d.set(e.locatorHash,"<recursive>");for(const e of a.dependencies.values()){const t=n.storedResolutions.get(e.descriptorHash);if(void 0===t)throw new Error(`Assertion failed: The resolution (${i.structUtils.prettyDescriptor(n.configuration,e)}) should have been registered`);const a=n.storedPackages.get(t);if(void 0===a)throw new Error("Assertion failed: The package should have been registered");o.update(h(a))}return t=o.digest("hex"),d.set(e.locatorHash,t),t},u=(0,c.createHash)("sha512").update(p).update(h(o)).update(r).digest("hex");n.storedBuildState.set(o.locatorHash,u),await n.persistInstallStateFile()}))).exitCode()}}l.paths=[["nixify","inject-build"]];const p=e("@yarnpkg/plugin-pnp"),d=JSON.stringify,h=(e,n,t=!1)=>n.split("\n").map((n=>n||t?e+n:n)).join("\n"),u=(e,n)=>{let t=e;for(const[e,a]of Object.entries(n))if("string"==typeof a&&(t=t.replace(new RegExp(`@@${e}@@`,"g"),a)),"boolean"==typeof a){const n=t.split("\n"),i=n.indexOf(`#@@ IF ${e}`),o=n.indexOf(`#@@ ENDIF ${e}`);-1!==i&&o>i&&(a?(n.splice(o,1),n.splice(i,1)):n.splice(i,o-i+1),t=n.join("\n"))}return t},f=["pnp","node-modules"];class g extends o.Command{constructor(...e){super(...e),this.binDir=o.Option.String()}async execute(){const e=await i.Configuration.find(this.context.cwd,this.context.plugins),{project:n,workspace:t}=await i.Project.find(e,this.context.cwd);return(await i.StreamReport.start({configuration:e,stdout:this.context.stdout},(async a=>{if(!t||0===t.manifest.bin.size)return;let i=e.get("nodeLinker");f.includes(i)||(i="node-modules",a.reportWarning(0,`The nodeLinker ${i} is not supported - executables may have trouble finding dependencies`));const o=s.npath.toPortablePath(this.binDir),r=(0,p.getPnpPath)(n).cjs;for(const[e,a]of t.manifest.bin){const t=s.ppath.join(o,e),c=s.ppath.join(n.cwd,s.npath.toPortablePath(a));let l;switch(i){case"pnp":l=u("#!/bin/sh\nexport NODE_OPTIONS=\"--require @@PNP_PATH@@\"\nexec '@@NODE_PATH@@' '@@SCRIPT_PATH@@' \"$@\"\n",{NODE_PATH:process.execPath,PNP_PATH:r,SCRIPT_PATH:c});break;case"node-modules":l=u("#!/bin/sh\nexec '@@NODE_PATH@@' '@@SCRIPT_PATH@@' \"$@\"\n",{NODE_PATH:process.execPath,SCRIPT_PATH:c});break;default:throw Error(`Assertion failed: Invalid nodeLinker ${i}`)}await s.xfs.writeFilePromise(t,l),await s.xfs.chmodPromise(t,493)}}))).exitCode()}}g.paths=[["nixify","install-bin"]];const m=e("@yarnpkg/plugin-patch"),y=(e,n)=>(0,c.createHash)(e).update(n).digest(),_=(e,n,t,a="/nix/store")=>{const i=t.toString("hex"),o=y("sha256",`fixed:out:${n}:${i}:`).toString("hex"),r=(e=>{let n="",t=[...e].reverse().map((e=>e.toString(2).padStart(8,"0"))).join("");for(;t;)n+="0123456789abcdfghijklmnpqrsvwxyz"[parseInt(t.slice(0,5),2)],t=t.slice(5);return n})(((e,n)=>{const t=Buffer.alloc(20);for(let n=0;n<e.length;n++)t[n%20]^=e[n];return t})(y("sha256",`output:out:sha256:${o}:${a}:${e}`)));return s.ppath.join(a,`${r}-${e}`)},v=e=>e.replace(/^\.+/,"").replace(/[^a-zA-Z0-9+._?=-]+/g,"-").slice(0,207)||"unknown",x=e("os"),$={commands:[r,l,g],hooks:{afterAllInstalled:async(e,n)=>{!1!==n.persistProject&&e.configuration.get("enableNixify")&&await(async(e,n,t)=>{const{configuration:a,cwd:o}=e,r=await s.xfs.realpathPromise(s.npath.toPortablePath((0,x.tmpdir)()));if(e.cwd.startsWith(r))return void t.reportInfo(0,`Skipping Nixify, because ${e.cwd} appears to be a temporary directory`);const c=a.get("yarnPath");let l=s.ppath.relative(o,c);l.startsWith("../")&&(l=c,t.reportWarning(0,`The Yarn path ${c} is outside the project - it may not be reachable by the Nix build`));const p=a.get("cacheFolder");let f=s.ppath.relative(o,p);f.startsWith("../")&&(f=p,t.reportWarning(0,`The cache folder ${p} is outside the project - it may not be reachable by the Nix build`));for(const e of a.sources.values())e.startsWith("<")||s.ppath.relative(o,e).startsWith("../")&&t.reportWarning(0,`The config file ${e} is outside the project - it may not be reachable by the Nix build`);const g=a.get("nixExprPath"),y=a.get("lockfileFilename"),$=s.ppath.relative(s.ppath.dirname(g),y),b=s.ppath.relative(s.ppath.dirname(g),l),k=new Map,P=new Set(await s.xfs.readdirPromise(n.cwd)),w={unstablePackages:e.conditionalLocators};for(const t of e.storedPackages.values()){const{locatorHash:a}=t,o=e.storedChecksums.get(a),r=n.getLocatorPath(t,o||null,w);if(!r)continue;const c=s.ppath.basename(r);if(!P.has(c))continue;const l=i.structUtils.stringifyLocator(t),p=o?o.split("/").pop():await i.hashUtils.checksumFile(r);k.set(l,{filename:c,sha512:p})}let E="cacheEntries = {\n";for(const[e,n]of k)E+=`${d(e)} = { ${[`filename = ${d(n.filename)};`,`sha512 = ${d(n.sha512)};`].join(" ")} };\n`;E+="};";const T=a.get("isolatedNixBuilds");let A=new Set,j=[],S=[];const N=a.get("nodeLinker"),C=a.get("pnpUnpluggedFolder"),O=(n,t=new Set)=>{const a=i.structUtils.stringifyLocator(n);if(k.has(a)&&t.add(a),i.structUtils.isVirtualLocator(n)){const a=e.storedPackages.get(i.structUtils.devirtualizeLocator(n).locatorHash);if(!a)throw Error("Assertion failed: The locator should have been registered");O(a,t)}if(n.reference.startsWith("patch:")){const a=e.storedPackages.get(m.patchUtils.parseLocator(n).sourceLocator.locatorHash);if(!a)throw Error("Assertion failed: The locator should have been registered");O(a,t)}for(const a of n.dependencies.values()){const n=e.storedResolutions.get(a.descriptorHash);if(!n)throw Error("Assertion failed: The descriptor should have been registered");const i=e.storedPackages.get(n);if(!i)throw Error("Assertion failed: The locator should have been registered");O(i,t)}return t};for(const n of e.storedBuildState.keys()){const t=e.storedPackages.get(n);if(!t)throw Error("Assertion failed: The locator should have been registered");if(!T.includes(t.name))continue;let a;if("pnp"!==N)throw Error(`The nodeLinker ${N} is not supported for isolated Nix builds`);a=s.ppath.relative(e.cwd,s.ppath.join(C,i.structUtils.slugifyLocator(t),i.structUtils.getIdentVendorPath(t)));let o=t;if(i.structUtils.isVirtualLocator(o)){const{locatorHash:n}=i.structUtils.devirtualizeLocator(o),t=e.storedPackages.get(n);if(!t)throw Error("Assertion failed: The locator should have been registered");o=t}const r=i.structUtils.stringifyLocator(o),c=i.structUtils.stringifyLocator(t),l=`isolated.${d(r)}`;if(!A.has(o)){A.add(o);const e=[...O(t)].sort().map((e=>`${d(e)}\n`)).join(""),n=`override${I=t.name,I.split(/[^a-zA-Z0-9]+/g).filter((e=>e)).map((e=>{return(n=e).slice(0,1).toUpperCase()+n.slice(1);var n})).join("")}Attrs`;S.push(`${l} = optionalOverride (args.${n} or null) (mkIsolatedBuild { ${[`pname = ${d(t.name)};`,`version = ${d(t.version)};`,`reference = ${d(o.reference)};`,`locators = [\n${e}];`].join(" ")} });`)}0===j.length&&j.push("# Copy in isolated builds."),j.push(`echo 'injecting build for ${t.name}'`,"yarn nixify inject-build \\",`  ${d(c)} \\`,`  \${${l}} \\`,`  ${d(a)}`)}var I;j.length>0&&j.push("echo 'running yarn install'");const L=e.topLevelWorkspace.manifest.name,H=L?i.structUtils.stringifyIdent(L):"workspace",R=u('# This file is generated by running "yarn install" inside your project.\n# Manual changes might be lost - proceed with caution!\n\n{ lib, nodejs, stdenv, fetchurl, writeText, writeShellScriptBin, git, cacert, gnused }:\n{ src, symlinkPackages ? false, overrideAttrs ? null, netrcFilePath ? null, secretsEnvVars ? null, ... } @ args:\n\nlet\n\n  yarnPath = ./@@YARN_PATH@@;\n  yarnRelativePathString = "./@@YARN_PATH@@";\n  yarnLock = ./@@LOCKFILE@@;\n  packageJson = ./package.json;\n  yarnrcYaml = builtins.path {\n    path = ./.yarnrc.yml;\n    name = "yarnrc.yml";\n  };\n  yarnPlugins = builtins.path {\n    path = ./.yarn/plugins;\n    name = "yarnPlugins";\n  };\n\n  cacheFolder = @@CACHE_FOLDER@@;\n\n  # Call overrideAttrs on a derivation if a function is provided.\n  optionalOverride = fn: drv:\n    if fn == null then drv else drv.overrideAttrs fn;\n\n  # Common attributes between Yarn derivations.\n  drvCommon = {\n    # Make sure the build uses the right Node.js version everywhere.\n    buildInputs = [ nodejs ];\n    # Tell node-gyp to use the provided Node.js headers for native code builds.\n    npm_config_nodedir = nodejs;\n    # Tell node-pre-gyp to never fetch binaries / always build from source.\n    npm_config_build_from_source = "true";\n    # Defines the shell alias to run Yarn.\n    postHook = \'\'\n      yarn() {\n        CI=1 node "${yarnPath}" "$@"\n      }\n    \'\';\n  };\n\n  setupProjectFiles = \'\'\n    # package.json cannot be symlinked since when executing "yarn run ...", yarn\n    # will follow the symlink and consider the location of the original file as\n    # the projects root directory.\n    cp ${packageJson} package.json\n    ln -s ${yarnLock} yarn.lock\n    ln -s ${yarnrcYaml} .yarnrc.yml\n\n    mkdir -p .yarn\n    ln -s ${yarnPlugins} .yarn/plugins\n\n    mkdir -p $(dirname ${yarnRelativePathString})\n    ln -s ${yarnPath} ${yarnRelativePathString}\n  \'\';\n\n  checkSandboxPathExists = writeShellScriptBin "check-sandbox-file-exists" \'\'\n    set -ueo pipefail\n\n    file_path=$1\n\n    if ! test -e "$file_path"\n    then\n      echo >&2 "Error: $file_path does not exist or cannot be accessed due to permissions!"\n      echo >&2 "  Make sure it\'s added to extra-sandbox-paths and that nixbld"\n      echo >&2 "  user group has read access to it."\n      exit 1\n    fi\n  \'\';\n\n  linkNetrcFile = writeShellScriptBin "link-netrc-file" \'\'\n    set -ueo pipefail\n\n    netrc_file_path=$1\n    home=$2\n\n    ${checkSandboxPathExists}/bin/check-sandbox-file-exists "$netrc_file_path"\n\n    if ! test -d "$home";\n    then\n      echo >&2 "given HOME path (\'\'${home}) does not exist or is not a directory"\n      exit 1\n    fi\n\n    echo >&2 "linking .netrc file at \'\'${netrc_file_path} to \'\'${home}"\n\n    ln -s "$netrc_file_path" "$home"\n  \'\';\n\n  exportEnvVarsFromFilesIfAny = envVarNamesToPaths:\n    if envVarNamesToPaths != null\n    # build a list of export statement\n    then lib.concatStringsSep "\\n" (lib.mapAttrsToList\n      (name: path: \'\'\n        check-sandbox-file-exists "${path}"\n        export ${name}=$(cat "${path}")\n      \'\')\n      envVarNamesToPaths\n    )\n    else ""\n  ;\n\n  # Create derivations for fetching dependencies.\n  cacheDrvs = let\n    builder = builtins.toFile "builder.sh" \'\'\n      source $stdenv/setup\n\n      ${exportEnvVarsFromFilesIfAny secretsEnvVars}\n\n      home=$TMP\n\n      ${\n        if netrcFilePath != null\n        then \'\'link-netrc-file "${netrcFilePath}" "$home"\'\'\n        else ""\n      }\n\n      build_dir=$TMP/build\n      mkdir -p $build_dir\n      cd $build_dir\n\n      ${setupProjectFiles}\n\n      mkdir -p ${cacheFolder}\n      YARN_CACHE_FOLDER=$(pwd)/${cacheFolder}\n\n      HOME="$home" \\\n        YARN_CACHE_FOLDER="$YARN_CACHE_FOLDER" \\\n        CI=1 \\\n        node \'${yarnPath}\' nixify fetch-one $locator\n\n      # Because we change the cache dir, Yarn may generate a different name.\n      output_filename_stripped=$(sed \'s/-[^-]*\\.[^-]*$//\' <<< "$outputFilename")\n\n      mv "$YARN_CACHE_FOLDER/$output_filename_stripped"-* $out\n    \'\';\n  in lib.mapAttrs (locator: { filename, sha512 }: stdenv.mkDerivation {\n    inherit builder locator;\n    # We need .zip extension since without pnp will not look inside the archive.\n    name = lib.strings.sanitizeDerivationName locator + ".zip";\n    buildInputs = [ nodejs ];\n    nativeBuildInputs = [ git cacert linkNetrcFile checkSandboxPathExists ];\n    outputFilename = filename;\n    outputHashMode = "flat";\n    outputHashAlgo = "sha512";\n    outputHash = sha512;\n  }) cacheEntries;\n\n  # Create a shell snippet to copy dependencies from a list of derivations.\n  mkCacheBuilderForDrvs = symlinkPackages: drvs:\n    writeText "collect-cache.sh" (lib.concatMapStrings (drv: \'\'\n      ${if symlinkPackages then "ln -s" else "cp"} ${drv} \'${drv.outputFilename}\'\n    \'\') drvs);\n\n#@@ IF NEED_ISOLATED_BUILD_SUPPRORT\n  # Create a shell snippet to copy dependencies from a list of locators.\n  mkCacheBuilderForLocators = let\n    pickCacheDrvs = map (locator: cacheDrvs.${locator});\n  in locators:\n    mkCacheBuilderForDrvs false (pickCacheDrvs locators);\n\n  # Create a derivation that builds a node-pre-gyp module in isolation.\n  mkIsolatedBuild = { pname, version, reference, locators }: stdenv.mkDerivation (drvCommon // {\n    inherit pname version;\n    phases = [ "buildPhase" "installPhase" ];\n\n    buildPhase = \'\'\n      runHook preBuild\n\n      mkdir -p .yarn/cache\n      pushd .yarn/cache > /dev/null\n      source ${mkCacheBuilderForLocators locators}\n      popd > /dev/null\n\n      echo \'{ "dependencies": { "${pname}": "${reference}" } }\' > package.json\n      install -m 0600 ${yarnLock} ./yarn.lock\n\n      yarn_global_folder="$TMP" \\\n        YARN_ENABLE_IMMUTABLE_INSTALLS=false \\\n        yarn --immutable-cache\n\n      runHook postBuild\n    \'\';\n\n    installPhase = \'\'\n      unplugged=( .yarn/unplugged/${pname}-*/node_modules/* )\n      if [[ ! -e "\'\'${unplugged[@]}" ]]; then\n        echo >&2 "Could not find the unplugged path for ${pname}"\n        exit 1\n      fi\n\n      mv "$unplugged" $out\n    \'\';\n  });\n#@@ ENDIF NEED_ISOLATED_BUILD_SUPPRORT\n\n  # Derivation with content of .yarn/cache and .pnp.cjs\n  deps = stdenv.mkDerivation (drvCommon // {\n    name = "@@PROJECT_NAME@@-deps";\n    # Disable Nixify plugin to save on some unnecessary processing.\n    yarn_enable_nixify = "false";\n    nativeBuildInputs = [gnused];\n\n    configurePhase = \'\'\n      ${setupProjectFiles}\n\n      # Copy over the Yarn cache.\n      mkdir -p ${cacheFolder}\n      pushd \'${cacheFolder}\' > /dev/null\n      source ${mkCacheBuilderForDrvs symlinkPackages (lib.attrValues cacheDrvs)}\n      popd > /dev/null\n\n      # Yarn may need a writable home directory.\n      export yarn_global_folder="$TMP"\n\n      # Some node-gyp calls may call out to npm, which could fail due to an\n      # read-only home dir.\n      export HOME="$TMP"\n\n      # running preConfigure after the cache is populated allows for\n      # preConfigure to contain substituteInPlace for dependencies as well as the\n      # main project. This is necessary for native bindings that maybe have\n      # hardcoded values.\n      runHook preConfigure\n\n@@ISOLATED_INTEGRATION@@\n\n      # Run normal Yarn install to complete dependency installation.\n      # YARN_VIRTUAL_FOLDER is set this way to make it easy to replace in\n      # installPhase below, so that in the end virtual paths resolve to\n      # packages in nix store.\n      YARN_CACHE_FOLDER=$(pwd)/${cacheFolder} \\\n        YARN_VIRTUAL_FOLDER=$(pwd)/__virtual__ \\\n        yarn install --immutable --immutable-cache\n\n      runHook postConfigure\n    \'\';\n\n    dontUnpack = true;\n    dontBuild = true;\n\n    installPhase = \'\'\n      runHook preInstall\n\n      # This needs nested under /nix/store at the same depth as the the location\n      # of the source in the output of project derivation so that\n      # relative_path_to_nix_store is valid from the final source.\n      output_dir=$out/libexec/deps\n      mkdir -p $output_dir\n\n      mkdir -p $output_dir/.yarn\n      test -d .yarn/cache && mv .yarn/cache $output_dir/.yarn/cache\n      test -d .yarn/unplugged && mv .yarn/unplugged $output_dir/.yarn/unplugged\n\n      mv .pnp.cjs $output_dir/.pnp.cjs\n\n      cd $output_dir\n\n      # Replace references from .pnp.cjs to symlinks in .yarn/cache with\n      # relative paths. Needed because of: https://github.com/yarnpkg/berry/issues/3514\n\n      # sed helpers\n      escape_sed_replacement () {\n        echo "$1" | sed -e \'s/[\\/&]/\\\\&/g\'\n      }\n\n      escape_sed_pattern () {\n        echo "$1" | sed -e \'s/[]\\/$*.^[]/\\\\&/g\'\n      }\n      echo >&2 "fixup paths in .pnp.cjs"\n\n      # TODO: this would be best done with a plugin which would resolve symlinks\n      #   to actual store paths during yarn install.\n      relative_path_to_nix_store=$(realpath --relative-to=. /nix/store)\n\n      unplugged_path_relative_to_nix_store=$(realpath --relative-to=/nix/store $output_dir/.yarn/unplugged)\n      echo unplugged_path_relative_to_nix_store: $unplugged_path_relative_to_nix_store\n\n      sed -E -i \\\n        -e "s/$(escape_sed_pattern \'./.yarn/cache\')/$(escape_sed_replacement "$relative_path_to_nix_store")/g" \\\n        -e "s/$(escape_sed_pattern \'./.yarn/unplugged\')/$(escape_sed_replacement "\'\'${relative_path_to_nix_store}/\'\'${unplugged_path_relative_to_nix_store}")/g" \\\n        -e "s/$(escape_sed_pattern \'0/.yarn/cache\')/0/g" \\\n        -e "s/$(escape_sed_pattern \'./__virtual__\')/$(escape_sed_replacement "$relative_path_to_nix_store/__virtual__")/g" \\\n        .pnp.cjs\n\n      for path in .yarn/cache/*; do\n        # Skip empty\n        test -z "$path" && continue\n\n        file_name_in_pnp=$(basename "$path")\n        file_name=$(basename $(realpath --relative-to=. "$path"))\n\n        # echo >&2 "replace for path:   $path"\n        # echo >&2 "  file_name_in_pnp: $file_name_in_pnp"\n        # echo >&2 "  with file_name:   $file_name"\n\n        sed -i "s/$(escape_sed_pattern "$file_name_in_pnp")/$(escape_sed_replacement "$file_name")/" .pnp.cjs\n      done\n\n      mkdir ../pnp\n      mv .pnp.cjs ../pnp\n      runHook postInstall\n    \'\';\n\n    passthru = {\n      inherit nodejs;\n    };\n  });\n\n  # Main project derivation.\n  project = stdenv.mkDerivation (drvCommon // {\n    inherit src;\n    name = "@@PROJECT_NAME@@";\n\n    configurePhase = \'\'\n      ${setupProjectFiles}\n      # We can\'t symlink this one since it doesn\'t work as a symlink due to\n      # packageLocations within it being relative path to this files locations\n      # real location, therefore it needs to be located at the root of the\n      # project for relative and workspace scoped imports to work.\n      cp ${deps}/libexec/pnp/.pnp.cjs .pnp.cjs\n\n      runHook postConfigure\n    \'\';\n\n    dontBuild = true;\n\n    installPhase = \'\'\n      runHook preInstall\n\n      mkdir -p $out/libexec $out/bin\n\n      # Move the entire project to the output directory.\n\n      mv $PWD "$out/libexec/$name"\n      cd "$out/libexec/$name"\n\n      # Invoke a plugin internal command to setup binaries.\n      yarn nixify install-bin $out/bin\n\n      runHook postInstall\n    \'\';\n\n    passthru = {\n      inherit nodejs;\n    };\n  });\n\n@@CACHE_ENTRIES@@\n@@ISOLATED@@\nin optionalOverride overrideAttrs project\n',{PROJECT_NAME:H,YARN_PATH:b,LOCKFILE:$,CACHE_FOLDER:d(f),CACHE_ENTRIES:E,ISOLATED:S.join("\n"),ISOLATED_INTEGRATION:h("      ",j.join("\n")),NEED_ISOLATED_BUILD_SUPPRORT:j.length>0});if(await s.xfs.writeFilePromise(a.get("nixExprPath"),R),a.get("generateDefaultNix")){const e=s.ppath.join(o,"default.nix"),n=s.ppath.join(o,"flake.nix");s.xfs.existsSync(e)||s.xfs.existsSync(n)||(await s.xfs.writeFilePromise(e,"# This is a minimal `default.nix` by yarn-plugin-nixify. You can customize it\n# as needed, it will not be overwritten by the plugin.\n\n{ pkgs ? import <nixpkgs> { } }:\n\npkgs.callPackage ./yarn-project.nix { } { src = ./.; }\n"),t.reportInfo(0,"A minimal default.nix was created. You may want to customize it."))}a.get("enableNixPreload")&&s.xfs.existsSync(s.npath.toPortablePath("/nix/store"))&&await s.xfs.mktempPromise((async a=>{const o=[];for(const[e,{filename:t,sha512:i}]of k.entries()){const r=v(e),c=Buffer.from(i,"hex"),l=_(r,"sha512",c);if(!s.xfs.existsSync(l)){const e=s.ppath.join(a,i.slice(0,7));await s.xfs.mkdirPromise(e);const c=s.ppath.join(n.cwd,t),l=s.ppath.join(e,r);await s.xfs.copyFilePromise(c,l),o.push(l)}}try{const n=o.length;for(;0!==o.length;){const n=o.splice(0,100);await i.execUtils.execvp("nix-store",["--add-fixed","sha512",...n],{cwd:e.cwd,strict:!0})}0!==n&&t.reportInfo(0,`Preloaded ${n} packages into the Nix store`)}catch(e){if("ENOENT"!==e.code)throw e}}))})(e,n.cache,n.report)}},configuration:{enableNixify:{description:"If false, disables the Nixify plugin hook that generates Nix expressions",type:i.SettingsType.BOOLEAN,default:!0},nixExprPath:{description:"Path of the file where the project Nix expression will be written to",type:i.SettingsType.ABSOLUTE_PATH,default:"./yarn-project.nix"},generateDefaultNix:{description:"If true, a default.nix will be generated if it does not exist",type:i.SettingsType.BOOLEAN,default:!0},enableNixPreload:{description:"If true, cached packages will be preloaded into the Nix store",type:i.SettingsType.BOOLEAN,default:!0},isolatedNixBuilds:{description:"Dependencies with a build step that can be built in an isolated derivation",type:i.SettingsType.STRING,default:[],isArray:!0}}},b=$;n=a})(),n}};