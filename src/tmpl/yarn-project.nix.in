# This file is generated by running "yarn install" inside your project.
# Manual changes might be lost - proceed with caution!

{ lib, nodejs, stdenv, fetchurl, writeText, writeShellScriptBin, git, cacert, gnused }:
{ src, symlinkPackages ? false, overrideAttrs ? null, netrcFilePath ? null, secretsEnvVars ? null, ... } @ args:

let

  yarnPath = ./@@YARN_PATH@@;
  lockfile = ./@@LOCKFILE@@;
  cacheFolder = @@CACHE_FOLDER@@;

  # Call overrideAttrs on a derivation if a function is provided.
  optionalOverride = fn: drv:
    if fn == null then drv else drv.overrideAttrs fn;

  # Common attributes between Yarn derivations.
  drvCommon = {
    # Make sure the build uses the right Node.js version everywhere.
    buildInputs = [ nodejs ];
    # Tell node-gyp to use the provided Node.js headers for native code builds.
    npm_config_nodedir = nodejs;
    # Tell node-pre-gyp to never fetch binaries / always build from source.
    npm_config_build_from_source = "true";
    # Defines the shell alias to run Yarn.
    postHook = ''
      yarn() {
        CI=1 node "${yarnPath}" "$@"
      }
    '';
  };

  checkSandboxPathExists = writeShellScriptBin "check-sandbox-file-exists" ''
    set -ueo pipefail

    file_path=$1

    if ! test -e "$file_path"
    then
      echo >&2 "Error: $file_path does not exist or cannot be accessed due to permissions!"
      echo >&2 "  Make sure it's added to extra-sandbox-paths and that nixbld"
      echo >&2 "  user group has read access to it."
      exit 1
    fi
  '';

  linkNetrcFile = writeShellScriptBin "link-netrc-file" ''
    set -ueo pipefail

    netrc_file_path=$1
    home=$2

    ${checkSandboxPathExists}/bin/check-sandbox-file-exists "$netrc_file_path"

    if ! test -d "$home";
    then
      echo >&2 "given HOME path (''${home}) does not exist or is not a directory"
      exit 1
    fi

    echo >&2 "linking .netrc file at ''${netrc_file_path} to ''${home}"

    ln -s "$netrc_file_path" "$home"
  '';

  exportEnvVarsFromFilesIfAny = envVarNamesToPaths:
    if envVarNamesToPaths != null
    # build a list of export statement
    then lib.concatStringsSep "\n" (lib.mapAttrsToList
      (name: path: ''
        check-sandbox-file-exists "${path}"
        export ${name}=$(cat "${path}")
      '')
      envVarNamesToPaths
    )
    else ""
  ;

  # Create derivations for fetching dependencies.
  cacheDrvs = let
    builder = builtins.toFile "builder.sh" ''
      source $stdenv/setup

      ${exportEnvVarsFromFilesIfAny secretsEnvVars}

      home=$TMP
      yarn_cache_folder=$home/cache
      mkdir -p $yarn_cache_folder

      ${
        if netrcFilePath != null
        then ''link-netrc-file "${netrcFilePath}" "$home"''
        else ""
      }

      cd "$src"
      HOME="$home" yarn_cache_folder="$yarn_cache_folder" CI=1 \
         node '${yarnPath}' nixify fetch-one $locator
      # Because we change the cache dir, Yarn may generate a different name.
      mv "$yarn_cache_folder/$(sed 's/-[^-]*\.[^-]*$//' <<< "$outputFilename")"-* $out
    '';
  in lib.mapAttrs (locator: { filename, sha512 }: stdenv.mkDerivation {
    inherit src builder locator;
    name = lib.strings.sanitizeDerivationName locator;
    buildInputs = [ nodejs git cacert ];
    buildInputs = [ nodejs ];
    nativeBuildInputs = [ git cacert linkNetrcFile checkSandboxPathExists ];
    outputFilename = filename;
    outputHashMode = "flat";
    outputHashAlgo = "sha512";
    outputHash = sha512;
  }) cacheEntries;

  # Create a shell snippet to copy dependencies from a list of derivations.
  mkCacheBuilderForDrvs = drvs:
    writeText "collect-cache.sh" (lib.concatMapStrings (drv: ''
      cp ${drv} '${drv.outputFilename}'
    '') drvs);

#@@ IF NEED_ISOLATED_BUILD_SUPPRORT
  # Create a shell snippet to copy dependencies from a list of locators.
  mkCacheBuilderForLocators = let
    pickCacheDrvs = map (locator: cacheDrvs.${locator});
  in locators:
    mkCacheBuilderForDrvs (pickCacheDrvs locators);

  # Create a derivation that builds a node-pre-gyp module in isolation.
  mkIsolatedBuild = { pname, version, reference, locators }: stdenv.mkDerivation (drvCommon // {
    inherit pname version;
    phases = [ "buildPhase" "installPhase" ];

    buildPhase = ''
      mkdir -p .yarn/cache
      pushd .yarn/cache > /dev/null
      source ${mkCacheBuilderForLocators locators}
      popd > /dev/null

      echo '{ "dependencies": { "${pname}": "${reference}" } }' > package.json
      install -m 0600 ${lockfile} ./yarn.lock
      export yarn_global_folder="$TMP"
      export YARN_ENABLE_IMMUTABLE_INSTALLS=false
      yarn --immutable-cache
    '';

    installPhase = ''
      unplugged=( .yarn/unplugged/${pname}-*/node_modules/* )
      if [[ ! -e "''${unplugged[@]}" ]]; then
        echo >&2 "Could not find the unplugged path for ${pname}"
        exit 1
      fi

      mv "$unplugged" $out
    '';
  });
#@@ ENDIF NEED_ISOLATED_BUILD_SUPPRORT

  # Main project derivation.
  project = stdenv.mkDerivation (drvCommon // {
    inherit src;
    name = @@PROJECT_NAME@@;
    # Disable Nixify plugin to save on some unnecessary processing.
    yarn_enable_nixify = "false";

    configurePhase = ''
      # Copy over the Yarn cache.
      rm -fr '${cacheFolder}'
      mkdir -p '${cacheFolder}'
      pushd '${cacheFolder}' > /dev/null
      source ${mkCacheBuilderForDrvs (lib.attrValues cacheDrvs)}
      popd > /dev/null

      # Yarn may need a writable home directory.
      export yarn_global_folder="$TMP"

      # Some node-gyp calls may call out to npm, which could fail due to an
      # read-only home dir.
      export HOME="$TMP"

      # running preConfigure after the cache is populated allows for
      # preConfigure to contain substituteInPlace for dependencies as well as the
      # main project. This is necessary for native bindings that maybe have
      # hardcoded values.
      runHook preConfigure

@@ISOLATED_INTEGRATION@@

      # Run normal Yarn install to complete dependency installation.
      yarn install --immutable --immutable-cache

      runHook postConfigure
    '';

    buildPhase = ''
      runHook preBuild
      runHook postBuild
    '';

    installPhase = ''
      runHook preInstall

      mkdir -p $out/libexec $out/bin

      # Move the entire project to the output directory.

      mv $PWD "$out/libexec/$name"
      cd "$out/libexec/$name"
      # Invoke a plugin internal command to setup binaries.
      yarn nixify install-bin $out/bin

      runHook postInstall
    '';

    passthru = {
      inherit nodejs;
    };
  });

@@CACHE_ENTRIES@@
@@ISOLATED@@
in optionalOverride overrideAttrs project
